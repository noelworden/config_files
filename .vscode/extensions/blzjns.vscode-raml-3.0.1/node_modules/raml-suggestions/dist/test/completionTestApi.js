/// <reference path="../../typings/main.d.ts" />
"use strict";
var completion = require('../index');
var path = require('path');
var fs = require('fs');
var SyncContentProvider = (function () {
    function SyncContentProvider() {
    }
    SyncContentProvider.prototype.contentDirName = function (content) {
        var contentPath = content.getPath();
        return path.dirname(contentPath);
    };
    SyncContentProvider.prototype.dirName = function (childPath) {
        return path.dirname(childPath);
    };
    SyncContentProvider.prototype.exists = function (checkPath) {
        return fs.existsSync(checkPath);
    };
    SyncContentProvider.prototype.resolve = function (contextPath, relativePath) {
        return path.resolve(contextPath, relativePath);
    };
    SyncContentProvider.prototype.isDirectory = function (dirPath) {
        var stat = fs.statSync(dirPath);
        return stat && stat.isDirectory();
    };
    SyncContentProvider.prototype.readDir = function (dirPath) {
        return fs.readdirSync(dirPath);
    };
    SyncContentProvider.prototype.existsAsync = function (path) {
        return Promise.reject("method disabled");
    };
    SyncContentProvider.prototype.readDirAsync = function (path) {
        return Promise.reject("method disabled");
    };
    SyncContentProvider.prototype.isDirectoryAsync = function (path) {
        return Promise.reject("method disabled");
    };
    return SyncContentProvider;
}());
var FSContent = (function () {
    function FSContent(filePath, offset) {
        this.filePath = filePath;
        this.offset = offset;
        this.text = fs.readFileSync(filePath).toString();
    }
    FSContent.prototype.getText = function () {
        return this.text;
    };
    FSContent.prototype.getPath = function () {
        return this.filePath;
    };
    FSContent.prototype.getBaseName = function () {
        return path.basename(this.filePath);
    };
    FSContent.prototype.getOffset = function () {
        return this.offset;
    };
    return FSContent;
}());
function offsetForEntry(entry, text) {
    return text.indexOf(entry) + entry.length;
}
function resolve(testPath) {
    return path.resolve(__dirname, '../../tests/' + testPath);
}
function completionByOffset(filePath, offset) {
    var content = new FSContent(resolve(filePath), offset);
    var result = completion.suggest(content, new SyncContentProvider());
    return result.map(function (suggestion) { return suggestion.displayText || suggestion.text; }).join(', ');
}
exports.completionByOffset = completionByOffset;
function completionByOffsetAsync(filePath, offset, callback) {
    var content = new FSContent(resolve(filePath), offset);
    var result = completion.suggestAsync(content, new SyncContentProvider());
    result.then(function (result) {
        callback(result.map(function (suggestion) { return suggestion.displayText || suggestion.text; }).join(', '));
    });
}
exports.completionByOffsetAsync = completionByOffsetAsync;
function completionByUniqueEntry(filePath, entry, begin) {
    if (begin === void 0) { begin = false; }
    var content = new FSContent(resolve(filePath), 0);
    var position = begin ? (content.getText().indexOf(entry)) : offsetForEntry(entry, content.getText());
    content.offset = position;
    var result = completion.suggest(content, new SyncContentProvider());
    return result.map(function (suggestion) { return suggestion.displayText || suggestion.text; }).join(', ');
}
exports.completionByUniqueEntry = completionByUniqueEntry;
function completionByUniqueEntryAsync(filePath, entry, begin, callback) {
    if (begin === void 0) { begin = false; }
    var content = new FSContent(resolve(filePath), 0);
    var position = begin ? (content.getText().indexOf(entry)) : offsetForEntry(entry, content.getText());
    content.offset = position;
    var result = completion.suggestAsync(content, completion.getContentProvider(new AsyncFSResolver()));
    result.then(function (result) {
        callback(result.map(function (suggestion) { return suggestion.displayText || suggestion.text; }).join(', '));
    });
}
exports.completionByUniqueEntryAsync = completionByUniqueEntryAsync;
var AsyncFSResolver = (function () {
    function AsyncFSResolver() {
    }
    AsyncFSResolver.prototype.content = function (path) {
        return null;
    };
    AsyncFSResolver.prototype.list = function (path) {
        return null;
    };
    ;
    AsyncFSResolver.prototype.exists = function (path) {
        return false;
    };
    AsyncFSResolver.prototype.contentAsync = function (path) {
        return new Promise(function (resolve, reject) {
            fs.readFile(path, function (err, content) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(content.toString());
            });
        });
    };
    AsyncFSResolver.prototype.dirname = function (filePath) {
        return path.dirname(filePath);
    };
    AsyncFSResolver.prototype.resolve = function (contextPath, relativePath) {
        return path.resolve(contextPath, relativePath);
    };
    AsyncFSResolver.prototype.extname = function (filePath) {
        return path.extname(filePath);
    };
    AsyncFSResolver.prototype.isDirectory = function (filePath) {
        return fs.statSync(filePath).isDirectory();
    };
    AsyncFSResolver.prototype.existsAsync = function (path) {
        return new Promise(function (resolve) {
            fs.exists(path, function (result) {
                resolve(result);
            });
        });
    };
    AsyncFSResolver.prototype.listAsync = function (path) {
        return new Promise(function (resolve) {
            fs.readdir(path, function (err, result) {
                resolve(result);
            });
        });
    };
    AsyncFSResolver.prototype.isDirectoryAsync = function (path) {
        return new Promise(function (resolve) {
            fs.stat(path, function (err, stats) {
                resolve(stats.isDirectory());
            });
        });
    };
    return AsyncFSResolver;
}());
//# sourceMappingURL=completionTestApi.js.map